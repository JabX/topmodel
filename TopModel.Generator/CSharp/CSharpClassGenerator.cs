using Microsoft.Extensions.Logging;
using TopModel.Core;
using TopModel.Core.FileModel;
using TopModel.Utils;

namespace TopModel.Generator.CSharp;

using static CSharpUtils;

public class CSharpClassGenerator : GeneratorBase<object>
{
    private readonly CSharpConfig _config;
    private readonly ILogger<CSharpClassGenerator> _logger;

    public CSharpClassGenerator(ILogger<CSharpClassGenerator> logger, CSharpConfig config)
        : base(logger, config)
    {
        _config = config;
        _logger = logger;
    }

    public override string Name => "CSharpClassGen";

    public override IEnumerable<string> GeneratedFiles => Classes.Select(c => _config.GetClassFileName(c));

    protected override void HandleFiles(IEnumerable<ModelFile> files)
    {
        foreach (var classe in files.SelectMany(file => file.Classes))
        {
            Generate(classe);
        }
    }

    /// <summary>
    /// Méthode générant le code d'une classe.
    /// </summary>
    /// <param name="item">Classe concernée.</param>
    protected void Generate(Class item)
    {
        if (item.Properties.OfType<IFieldProperty>().Any(p => p.Domain.CSharp == null))
        {
            throw new ModelException(item, $"Le type C# de tous les domaines des propriétés de {item.Name} doit être défini.");
        }

        var fileName = _config.GetClassFileName(item);

        using var w = new CSharpWriter(fileName, _logger, _config.UseLatestCSharp);

        GenerateUsings(w, item);
        w.WriteNamespace(_config.GetNamespace(item));
        w.WriteSummary(1, item.Comment);
        GenerateClassDeclaration(w, item);
        w.WriteNamespaceEnd();
    }

    /// <summary>
    /// Génère le constructeur par recopie d'un type base.
    /// </summary>
    /// <param name="w">Writer.</param>
    /// <param name="item">Classe générée.</param>
    private static void GenerateBaseCopyConstructor(CSharpWriter w, Class item)
    {
        if (item.Extends != null)
        {
            w.WriteLine();
            w.WriteSummary(2, "Constructeur par base class.");
            w.WriteParam("bean", "Source.");
            w.WriteLine(2, "public " + item.Name + "(" + item.Extends.Name + " bean)");
            w.WriteLine(3, ": base(bean)");
            w.WriteLine(2, "{");
            w.WriteLine(3, "OnCreated();");
            w.WriteLine(2, "}");
        }
    }

    /// <summary>
    /// Génération des constantes statiques.
    /// </summary>
    /// <param name="w">Writer.</param>
    /// <param name="item">La classe générée.</param>
    private static void GenerateConstProperties(CSharpWriter w, Class item)
    {
        if (item.ReferenceValues.Any())
        {
            foreach (var refValue in item.ReferenceValues.OrderBy(x => x.Name, StringComparer.Ordinal))
            {
                var code = item.PrimaryKey == null || !item.PrimaryKey.Domain.AutoGeneratedValue
                    ? refValue.Value[item.PrimaryKey ?? item.Properties.OfType<IFieldProperty>().First()]
                    : refValue.Value[item.UniqueKeys.First().Single()];
                var label = item.DefaultProperty != null
                    ? refValue.Value[item.DefaultProperty]
                    : refValue.Name;

                w.WriteSummary(2, label);
                w.WriteLine(2, string.Format("public const string {0} = \"{1}\";", refValue.Name, code));
                w.WriteLine();
            }
        }
    }

    /// <summary>
    /// Génère les constructeurs.
    /// </summary>
    /// <param name="w">Writer.</param>
    /// <param name="item">La classe générée.</param>
    private static void GenerateConstructors(CSharpWriter w, Class item)
    {
        GenerateDefaultConstructor(w, item);
        GenerateCopyConstructor(w, item);
        GenerateBaseCopyConstructor(w, item);
    }

    /// <summary>
    /// Génère le constructeur par recopie.
    /// </summary>
    /// <param name="w">Writer.</param>
    /// <param name="item">Classe générée.</param>
    private static void GenerateCopyConstructor(CSharpWriter w, Class item)
    {
        w.WriteLine();
        w.WriteSummary(2, "Constructeur par recopie.");
        w.WriteParam("bean", "Source.");
        if (item.Extends != null)
        {
            w.WriteLine(2, "public " + item.Name + "(" + item.Name + " bean)");
            w.WriteLine(3, ": base(bean)");
            w.WriteLine(2, "{");
        }
        else
        {
            w.WriteLine(2, "public " + item.Name + "(" + item.Name + " bean)");
            w.WriteLine(2, "{");
        }

        w.WriteLine(3, "if (bean == null)");
        w.WriteLine(3, "{");
        w.WriteLine(4, "throw new ArgumentNullException(nameof(bean));");
        w.WriteLine(3, "}");
        w.WriteLine();

        var initd = new List<string>();

        foreach (var property in item.Properties.OfType<IFieldProperty>().Where(t => t.Domain.CSharp!.Type.Contains("ICollection")))
        {
            initd.Add(property.Name);
            var strip = property.Domain.CSharp!.Type.ParseTemplate(property).Replace("ICollection<", string.Empty).Replace(">", string.Empty);
            w.WriteLine(3, property.Name + " = new List<" + strip + ">(bean." + property.Name + ");");
        }

        foreach (var property in item.Properties.OfType<CompositionProperty>().Where(p => p.Kind == "object"))
        {
            w.WriteLine(3, property.Name + " = new " + property.Composition.Name + "(bean." + property.Name + ");");
        }

        foreach (var property in item.Properties.OfType<CompositionProperty>().Where(p => p.Kind == "list"))
        {
            w.WriteLine(3, property.Name + " = new List<" + property.Composition.Name + ">(bean." + property.Name + ");");
        }

        foreach (var property in item.Properties.Where(p => p is not CompositionProperty && !initd.Contains(p.Name)))
        {
            w.WriteLine(3, property.Name + " = bean." + property.Name + ";");
        }

        w.WriteLine();
        w.WriteLine(3, "OnCreated(bean);");
        w.WriteLine(2, "}");
    }

    /// <summary>
    /// Génère le constructeur par défaut.
    /// </summary>
    /// <param name="w">Writer.</param>
    /// <param name="item">Classe générée.</param>
    private static void GenerateDefaultConstructor(CSharpWriter w, Class item)
    {
        w.WriteSummary(2, "Constructeur.");
        w.WriteLine(2, $@"public {item.Name}()");

        if (item.Extends != null)
        {
            w.WriteLine(3, ": base()");
        }

        w.WriteLine(2, "{");

        var line = false;
        foreach (var property in item.Properties.OfType<IFieldProperty>().Where(t => t.Domain.CSharp!.Type.Contains("ICollection")))
        {
            line = true;
            var strip = property.Domain.CSharp!.Type.ParseTemplate(property).Replace("ICollection<", string.Empty).Replace(">", string.Empty);
            w.WriteLine(3, LoadPropertyInit(property.Name, "List<" + strip + ">"));
        }

        foreach (var property in item.Properties.OfType<CompositionProperty>().Where(p => p.Kind == "object"))
        {
            line = true;
            w.WriteLine(3, LoadPropertyInit(property.Name, property.Composition.Name));
        }

        foreach (var property in item.Properties.OfType<CompositionProperty>().Where(p => p.Kind == "list"))
        {
            line = true;
            w.WriteLine(3, LoadPropertyInit(property.Name, "List<" + property.Composition.Name + ">"));
        }

        if (line)
        {
            w.WriteLine();
        }

        w.WriteLine(3, "OnCreated();");
        w.WriteLine(2, "}");
    }

    /// <summary>
    /// Génère les méthodes d'extensibilité.
    /// </summary>
    /// <param name="w">Writer.</param>
    /// <param name="item">Classe générée.</param>
    private static void GenerateExtensibilityMethods(CSharpWriter w, Class item)
    {
        w.WriteLine();
        w.WriteSummary(2, "Methode d'extensibilité possible pour les constructeurs.");
        w.WriteLine(2, "partial void OnCreated();");
        w.WriteLine();
        w.WriteSummary(2, "Methode d'extensibilité possible pour les constructeurs par recopie.");
        w.WriteParam("bean", "Source.");
        w.WriteLine(2, $"partial void OnCreated({item.Name} bean);");
    }

    /// <summary>
    /// Retourne le code associé à l'instanciation d'une propriété.
    /// </summary>
    /// <param name="fieldName">Nom de la variable membre privée.</param>
    /// <param name="dataType">Type de données.</param>
    /// <returns>Code généré.</returns>
    private static string LoadPropertyInit(string fieldName, string dataType)
    {
        var res = $"{fieldName} = ";
        if (IsCSharpBaseType(dataType))
        {
            res += GetCSharpDefaultValueBaseType(dataType) + ";";
        }
        else
        {
            res += $"new {dataType}();";
        }

        return res;
    }

    /// <summary>
    /// Génère le type énuméré présentant les colonnes persistentes.
    /// </summary>
    /// <param name="w">Writer.</param>
    /// <param name="item">La classe générée.</param>
    private static void GenerateEnumCols(CSharpWriter w, Class item)
    {
        w.WriteLine();
        w.WriteSummary(2, "Type énuméré présentant les noms des colonnes en base.");

        if (item.Extends == null)
        {
            w.WriteLine(2, "public enum Cols");
        }
        else
        {
            w.WriteLine(2, "public new enum Cols");
        }

        w.WriteLine(2, "{");

        var cols = item.Properties.OfType<IFieldProperty>().ToList();
        foreach (var property in cols)
        {
            w.WriteSummary(3, "Nom de la colonne en base associée à la propriété " + property.Name + ".");
            w.WriteLine(3, $"{property.SqlName},");
            if (cols.IndexOf(property) != cols.Count - 1)
            {
                w.WriteLine();
            }
        }

        w.WriteLine(2, "}");
    }

    /// <summary>
    /// Génère l'enum pour les valeurs statiques de références.
    /// </summary>
    /// <param name="w">Writer.</param>
    /// <param name="item">La classe générée.</param>
    private static void GenerateEnumValues(CSharpWriter w, Class item)
    {
        w.WriteSummary(2, $"Valeurs possibles de la liste de référence {item}.");
        w.WriteLine(2, $"public enum {item.PrimaryKey!.Name}s");
        w.WriteLine(2, "{");

        var refs = item.ReferenceValues.OrderBy(x => x.Name, StringComparer.Ordinal).ToList();
        foreach (var refValue in refs)
        {
            var code = refValue.Value[item.PrimaryKey];

            var label = item.DefaultProperty != null
                ? refValue.Value[item.DefaultProperty]
                : refValue.Name;

            w.WriteSummary(3, label);
            w.Write(3, code);

            if (refs.IndexOf(refValue) != refs.Count - 1)
            {
                w.WriteLine(",");
            }

            w.WriteLine();
        }

        w.WriteLine(2, "}");
    }

    /// <summary>
    /// Génère les flags d'une liste de référence statique.
    /// </summary>
    /// <param name="w">Writer.</param>
    /// <param name="item">La classe générée.</param>
    private static void GenerateFlags(CSharpWriter w, Class item)
    {
        if (item.FlagProperty != null && item.ReferenceValues.Any())
        {
            w.WriteLine();
            w.WriteLine(2, "#region Flags");
            w.WriteLine();
            w.WriteSummary(2, "Flags");
            w.WriteLine(2, "public enum Flags");
            w.WriteLine(2, "{");

            var flagValues = item.ReferenceValues.Where(refValue => refValue.Value.ContainsKey(item.FlagProperty) && int.TryParse(refValue.Value[item.FlagProperty], out var _)).ToList();
            foreach (var refValue in flagValues)
            {
                var flag = int.Parse(refValue.Value[item.FlagProperty]);
                var label = item.DefaultProperty != null
                    ? refValue.Value[item.DefaultProperty]
                    : refValue.Name;

                w.WriteSummary(3, label);
                w.WriteLine(3, $"{refValue.Name} = 0b{Convert.ToString(flag, 2)},");
                if (flagValues.IndexOf(refValue) != flagValues.Count - 1)
                {
                    w.WriteLine();
                }
            }

            w.WriteLine(2, "}");
            w.WriteLine();
            w.WriteLine(2, "#endregion");
        }
    }

    /// <summary>
    /// Génération de la déclaration de la classe.
    /// </summary>
    /// <param name="w">Writer</param>
    /// <param name="item">Classe à générer.</param>
    private void GenerateClassDeclaration(CSharpWriter w, Class item)
    {
        if (item.Reference && _config.Kinetix)
        {
            var primaryKey = item.PrimaryKey ?? item.Properties.OfType<IFieldProperty>().First();
            if (!primaryKey.Domain.AutoGeneratedValue)
            {
                w.WriteAttribute(1, "Reference", "true");
            }
            else
            {
                w.WriteAttribute(1, "Reference");
            }
        }

        if (item.DefaultProperty != null)
        {
            w.WriteAttribute(1, "DefaultProperty", $@"nameof({item.DefaultProperty.Name})");
        }

        if (item.IsPersistent && !_config.NoPersistance)
        {
            var sqlName = _config.UseLowerCaseSqlNames ? item.SqlName.ToLower() : item.SqlName;
            if (_config.DbSchema != null)
            {
                w.WriteAttribute(1, "Table", $@"""{sqlName}""", $@"Schema = ""{_config.DbSchema.Replace("{module}", item.Namespace.Module.ToSnakeCase())}""");
            }
            else
            {
                w.WriteAttribute(1, "Table", $@"""{sqlName}""");
            }
        }

        foreach (var annotation in item.Decorators.SelectMany(d => (d.Decorator.CSharp?.Annotations ?? Array.Empty<string>()).Select(a => a.ParseTemplate(item, d.Parameters)).Distinct()))
        {
            w.WriteAttribute(1, annotation);
        }

        var extendsDecorator = item.Decorators.SingleOrDefault(d => d.Decorator.CSharp?.Extends != null);
        w.WriteClassDeclaration(
            item.Name,
            item.Extends?.Name ?? extendsDecorator.Decorator?.CSharp?.Extends!.ParseTemplate(item, extendsDecorator.Parameters),
            item.Decorators.SelectMany(d => (d.Decorator.CSharp?.Implements ?? Array.Empty<string>()).Select(i => i.ParseTemplate(item, d.Parameters)).Distinct()).ToArray());

        if (!_config.CanClassUseEnums(item))
        {
            GenerateConstProperties(w, item);
        }

        GenerateConstructors(w, item);

        if (_config.DbContextPath == null && item.IsPersistent && !_config.NoPersistance)
        {
            w.WriteLine();
            w.WriteLine(2, "#region Meta données");
            GenerateEnumCols(w, item);
            w.WriteLine();
            w.WriteLine(2, "#endregion");
        }

        if (_config.CanClassUseEnums(item))
        {
            w.WriteLine();
            GenerateEnumValues(w, item);
        }

        GenerateFlags(w, item);
        GenerateProperties(w, item);
        GenerateExtensibilityMethods(w, item);
        w.WriteLine(1, "}");
    }

    /// <summary>
    /// Génère les propriétés.
    /// </summary>
    /// <param name="w">Writer.</param>
    /// <param name="item">La classe générée.</param>
    private void GenerateProperties(CSharpWriter w, Class item)
    {
        var sameColumnSet = new HashSet<string>(item.Properties.OfType<IFieldProperty>()
            .GroupBy(g => g.SqlName).Where(g => g.Count() > 1).Select(g => g.Key));
        foreach (var property in item.Properties)
        {
            w.WriteLine();
            GenerateProperty(w, property, sameColumnSet);
        }
    }

    /// <summary>
    /// Génère la propriété concernée.
    /// </summary>
    /// <param name="w">Writer.</param>
    /// <param name="property">La propriété générée.</param>
    /// <param name="sameColumnSet">Sets des propriétés avec le même nom de colonne, pour ne pas les gérerer (genre alias).</param>
    private void GenerateProperty(CSharpWriter w, IProperty property, HashSet<string> sameColumnSet)
    {
        w.WriteSummary(2, property.Comment);

        var type = _config.GetPropertyTypeName(property, useIEnumerable: false);

        if (property is AssociationProperty a && a.Type != AssociationType.ManyToOne && a.Type != AssociationType.OneToOne)
        {
            throw new ModelException(a, $"Le type d'association {a.Type} n'est pas supporté par le générateur C#");
        }

        if (property is IFieldProperty fp)
        {
            var prop = fp is AliasProperty alp && (!fp.Class.IsPersistent || alp.Property is AssociationProperty) ? alp.Property : fp;
            if ((!_config.NoColumnOnAlias || fp is not AliasProperty || fp.Class.IsPersistent) && fp is not AliasProperty { AsList: true } && (prop.Class.IsPersistent || fp.Class.IsPersistent) && !_config.NoPersistance && !sameColumnSet.Contains(prop.SqlName))
            {
                var sqlName = _config.UseLowerCaseSqlNames ? prop.SqlName.ToLower() : prop.SqlName;
                if (fp.Domain.CSharp!.UseSqlTypeName)
                {
                    w.WriteAttribute(2, "Column", $@"""{sqlName}""", $@"TypeName = ""{fp.Domain.SqlType}""");
                }
                else
                {
                    w.WriteAttribute(2, "Column", $@"""{sqlName}""");
                }
            }

            if (fp.Required && !fp.PrimaryKey || fp is AliasProperty { PrimaryKey: true })
            {
                w.WriteAttribute(2, "Required");
            }

            if (_config.Kinetix)
            {
                if (prop is AssociationProperty ap && ap.Association.IsPersistent && ap.Association.Reference)
                {
                    w.WriteAttribute(2, "ReferencedType", $"typeof({ap.Association.Name})");
                }
                else if (fp is AliasProperty alp2 && !alp2.PrimaryKey && alp2.Property.PrimaryKey && alp2.Property.Class.Reference)
                {
                    w.WriteAttribute(2, "ReferencedType", $"typeof({alp2.Property.Class.Name})");
                }
            }

            if (_config.Kinetix)
            {
                w.WriteAttribute(2, "Domain", $@"Domains.{fp.Domain.CSharpName}");
            }

            if (type == "string" && fp.Domain.Length != null)
            {
                w.WriteAttribute(2, "StringLength", $"{fp.Domain.Length}");
            }

            foreach (var annotation in fp.Domain.CSharp!.Annotations
                .Where(a => ((a.Target & Target.Dto) > 0) || ((a.Target & Target.Persisted) > 0) && (property.Class?.IsPersistent ?? false))
                .Select(a => a.Text.ParseTemplate(property)))
            {
                w.WriteAttribute(2, annotation);
            }
        }
        else
        {
            w.WriteAttribute(2, "NotMapped");
        }

        if (property.PrimaryKey && property is RegularProperty)
        {
            w.WriteAttribute(2, "Key");
        }

        var defaultValue = _config.GetDefaultValue(property, Classes);

        w.WriteLine(2, $"public {type} {property.Name} {{ get; set; }}{(defaultValue != "null" ? $" = {defaultValue};" : string.Empty)}");
    }

    /// <summary>
    /// Génération des imports.
    /// </summary>
    /// <param name="w">Writer.</param>
    /// <param name="item">Classe concernée.</param>
    private void GenerateUsings(CSharpWriter w, Class item)
    {
        var usings = new List<string>();

        if (!_config.UseLatestCSharp)
        {
            usings.Add("System");

            if (item.Properties.Any(p => p is CompositionProperty { Kind: "list" }))
            {
                usings.Add("System.Collections.Generic");
            }
        }

        if (item.DefaultProperty != null)
        {
            usings.Add("System.ComponentModel");
        }

        if (item.Properties.OfType<IFieldProperty>().Any(p => p.Required || p.PrimaryKey || p.Domain.CSharp!.Type == "string" && p.Domain.Length != null))
        {
            usings.Add("System.ComponentModel.DataAnnotations");
        }

        if (item.Properties.Any(p => p is CompositionProperty) ||
            item.Properties.OfType<IFieldProperty>().Any(fp =>
            {
                var prop = fp is AliasProperty alp ? alp.Property : fp;
                return (!_config.NoColumnOnAlias || fp is not AliasProperty) && prop.Class.IsPersistent && !_config.NoPersistance;
            }))
        {
            usings.Add("System.ComponentModel.DataAnnotations.Schema");
        }

        if (item.Properties.OfType<IFieldProperty>().Any() && _config.Kinetix)
        {
            usings.Add("Kinetix.Modeling.Annotations");
            usings.Add($"{item.Namespace.App}.Common");
        }

        if (item.Extends != null)
        {
            usings.Add(_config.GetNamespace(item.Extends));
        }

        foreach (var @using in item.Decorators.SelectMany(d => (d.Decorator.CSharp?.Usings ?? Array.Empty<string>()).Select(u => u.ParseTemplate(item, d.Parameters)).Distinct()))
        {
            usings.Add(@using);
        }

        foreach (var property in item.Properties)
        {
            if (property is IFieldProperty fp)
            {
                foreach (var @using in fp.Domain.CSharp!.Usings.Select(u => u.ParseTemplate(fp)))
                {
                    usings.Add(@using);
                }

                foreach (var @using in fp.Domain.CSharp!.Annotations
                    .Where(a => ((a.Target & Target.Dto) > 0) || ((a.Target & Target.Persisted) > 0) && (property.Class?.IsPersistent ?? false))
                    .SelectMany(a => a.Usings)
                    .Select(u => u.ParseTemplate(fp)))
                {
                    usings.Add(@using);
                }
            }

            switch (property)
            {
                case AssociationProperty { Association.IsPersistent: true, Association.Reference: true } ap:
                    usings.Add(_config.GetNamespace(ap.Association));
                    break;
                case AliasProperty { Property: AssociationProperty { Association.IsPersistent: true, Association.Reference: true } ap2 }:
                    usings.Add(_config.GetNamespace(ap2.Association));
                    break;
                case AliasProperty { PrimaryKey: false, Property: RegularProperty { PrimaryKey: true, Class.Reference: true } rp }:
                    usings.Add(_config.GetNamespace(rp.Class));
                    break;
                case CompositionProperty cp:
                    usings.Add(_config.GetNamespace(cp.Composition));
                    if (cp.DomainKind != null)
                    {
                        usings.AddRange(cp.DomainKind.CSharp!.Usings.Select(u => u.ParseTemplate(cp)));
                        usings.AddRange(cp.DomainKind.CSharp!.Annotations
                        .Where(a => ((a.Target & Target.Dto) > 0) || ((a.Target & Target.Persisted) > 0) && (property.Class?.IsPersistent ?? false))
                        .SelectMany(a => a.Usings)
                        .Select(u => u.ParseTemplate(cp)));
                    }

                    break;
            }
        }

        w.WriteUsings(usings
            .Where(u => u != _config.GetNamespace(item))
            .Distinct()
            .ToArray());

        if (usings.Any())
        {
            w.WriteLine();
        }
    }
}